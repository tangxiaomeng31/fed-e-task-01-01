# ECMAscript模块

**在浏览器环境中，JavaScript分为两大部分，一个是ECMAScript，一个是node api：BOM和DOM**

在编写代码之前需要构建一下项目，添加一下工具。
首先用到的就是package.json：在node.js中，模块是一个库或者框架，也是一个node.js项目。node.js遵循模块化的架构，当我们创建了一个node.js项目，意味着创建了一个模块，这个模块的描述文件就是package.json
nodemon: 修改代码后自动执行代码
> 安装nodemon: `npm install -g nodemon` (-g 代表全局安装，代表所有项目无论有没安装 nodemon，都可以直接在命令行上运行，因此我们不会在项目里的 node_modules 看到 nodemon。)

## let与块级作用域
在ES2015之前是没有块级作用域的，写在{ }内的变量在{ }外面也能取到

var会导致变量提升问题，let就不会

## 模板字符串
`${这里可以传入js语句}`  支持换行

## 带标签的模板字符串
    const name = 'aaa'
    const age = 10
    function tage(strings, name, age) {
    	//可以在这里进行一些处理
        console.log(strings, name, age) //['name:','age:']  'aaa'  10
    }
    const result = tags`name:${name}age:${age}`

## 字符串的扩展方法
    const MESSAGE = 'Error: foo is undefined.'
    function strFun(message) {
        //判断字符串的开头是否以xx开始
        console.log(message.startsWith('Error')) //true
        //判断字符串是否以xxx结尾
        console.log(message.endsWith('.')) //true
        //判断字符串是否包含xxx
        console.log(message.includes('foo')) //true
    }
    strFun(MESSAGE);

## 剩余参数
    function func(...args) {
    	console.log(args) //[1,2,3]
    }
    func(1,2,3)

## 箭头函数和this
普通函数的this指向他的调用者，而箭头函数的this指向调用者的上下文环境，箭头函数本身是没有this指向的。
这里要注意的是，这个函数的执行环境是浏览器环境还是node环境。浏览器环境因为有window对象。

    const person = {
        name: 'aaa',
        sayHi: () => {
            console.log(this.name) ;
        },
        sayHiAync: function () {
            setTimeout(function() {
                console.log(this.name) ;
            }, 1000)
        }
    }
    person.sayHi() //aaa
    person.sayHiAync() //undefined

## 对象字面量增强

    const name = 'abc';
    let obj = {
        method1() {
            console.log(111)
        },
        [name]: 'myName'
    }
    console.log(obj.method1()) //111
    console.log(obj.abc) //myName


## 对象扩展方法
`Object.assign()`: 将多个源对象中的属性复制到一个对象目标中

    const assigns = {
        a: 123,
        b: 456
    };
    const target = {
        a: 456,
        c: 789
    }
    let result = Object.assign(target, assigns) //参数1是目标对象，参数2是源对象
    console.log(result) // {a: 123, b: 456, c: 789}
    console.log(result === target) //true 返回的值为目标对象，并没有改变对象的地址

    function funs(obj) {
        // obj.name = 'name1'
        // console.log(obj)
        let objs = Object.assign({}, obj) //新的内存地址，不会覆盖obj1
        objs.name = 'name1'
        console.log(objs)
    }
    const obj1 = {name: 'glob obj'}
    funs(obj1)

## Proxy
Proxy（代理对象）用于监视对象的操作过程，是以非侵入的方式监听
defineProperty只能监听对象的读写

    const person = {
        name: 'name',
        age: 10
    }
    const personPoxy = new Proxy(person, {
        //监视代理目标属性的访问
        get(target, property) {
            //target为代理目标对象，外部访问的property属性名
            console.log(target, property);
        },
        //监视代理目标设置属性的过程
        set(target, property, value) {
            //target为代理目标对象，外部设置的property属性名, value为设置的属性值
            console.log(target, property, value);
            target[property] = value;
        },
        //监视代理目标删除操作
        deleteProperty(target, property) {
            //target为代理目标对象，property要删除的属性名
            console.log('delet:', property);
            delete target[property]
        }
    }) //第一个参数是需要代理的目标对象, 第二个参数是代理的处理对象
    console.log(personPoxy.name)
    personPoxy.sex = '女';
    console.log(person)
    delete personPoxy['sex']
    console.log(person)

	//监视数组
    const list = []
    const proxyList = new Proxy(list, {
        //用于监视数组的写入操作
        set(target, property, value) {
            //property此时对应的是数组的下标
            console.log('set', property, value)
            target[property] = value
            return true //表示写入成功
        }
    })
    proxyList.push(100)
除此之外还有更多的操作监听。

## Reflect
Reflect封装了对对象的底层操作，不能通过new实例化一个方法，只能调用他封装的方法
Reflect成员方法就是proxy处理对象的默认实现
意义在于提供了一套统一操作对象的api（一共13个）

    const obj = {
        name: 'zzz',
        age: 10
    }
    console.log(Reflect.has(obj, 'name'))
    console.log(Reflect.deleteProperty(obj, 'age'))
    console.log(Reflect.ownKeys(obj))

## class类

    function Person(name) {
        this.name
    }
    Person.prototype.say = function() {
        console.log('say')
    }
    
    class Person {
        constructor(name) {
            this.name = name
        }
    
        say() {
            console.log('say'+this.name)
        }
    
        //静态方法，用于创建Person类型的实例
        static create(name) {
            return new Person(name)
        }
    }
    // const p = new Person('tom')
    // p.create()
    const tom = Person.create('tom') //由于静态方法是挂载到类型上面的，所以静态方法的内部的this指向的是当前的类型，而不是一个新的实例对象
    tom.say()

## 静态方法
类型中的方法一般分为实例方法和静态方法
实例方法：需要通过这个类型构造的实例对象去调用
静态方法：直接通过类型本身去调用，实例化对象无法访问，new一个实例化对象不会被继承这个静态方法
> 参考代码参照上面class模块

## 继承

    class Person {
        constructor(name) {
            this.name = name
        }
    
        say() {
            console.log('say'+this.name)
        }
    }
    
    class Student extends Person {
        constructor(name, number) {
            //super指向父类，调用他等于调用父类的构造函数
            super(name);
            this.number = number;
        }
    
        hello () {
            //调用父类的方法
            super.say();
            console.log('my number is', this.number)
        }
    }
    const s = new Student(1414)
    s.hello()

## 这一模块遇见的问题：
1. package.json和package-lock.json问题
这个其实是Npm5之后,npm install 都会有一个package-lock.json文件，原来package.json文件只能锁定大版本，也就是版本号的第一位，并不能锁定后面的小版本，每次npm install都是拉取的该大版本下的最新的版本。package-lock.json功能，为的是让开发者知道只要你保存了源文件，到一个新的机器上、或者新的下载源，只要按照这个package-lock.json所标示的具体版本下载依赖库包，就能确保所有库包与你上次安装的完全一样。
2. 闭包
闭包函数：声明在一个函数中的函数，叫做闭包函数。
闭包：内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。


